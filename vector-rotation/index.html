<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A random collection of stuff I didn't want to forget"><link rel="shortcut icon" href=https://vlek.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Vector Rotation</title></head><body><header id=banner><h2><a href=https://vlek.github.io>Vlek's Personal Blog</a></h2><br><i>A random collection of stuff I didn't want to forget</i><nav><ul></ul></nav></header><main id=content><section id=main><h1 id=title>Vector Rotation</h1><aside id=meta><h4 id=date>Mon Mar 27, 2023</h4><h5 id=wordcount>752 Words</h5></aside><div><article id=content><h1>Table of Contents</h1><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#algorithm>Algorithm</a></li><li><a href=#example-case-asteroids-spaceship>Example case: Asteroids Spaceship</a><ul><li><a href=#setup-code>Setup code</a></li></ul></li><li><a href=#example-case-code>Example Case Code</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><p><img src=/vector-rotation/assets/rotation.gif alt="Rotating spaceship"></p><h1 id=introduction>Introduction</h1><p>Rotating a point or a shape around a fixed point is useful in a number of
scenarios, especially when it comes to game making. A number of effects, such as
having a facing direction, floating shapes, rotation, and other graphical
changes can all be handled using this base formula.</p><p>While creating an Asteroids clone, I needed to be able to handle rotation of the
player&rsquo;s space ship which I had drawn using vector graphics. Three X/Y
coordinates were being saved and lines drawn between them in order to draw the
ship which needed to be rotated based on which direction the player was facing
at any given time. For this, I used 2D rotation around an origin point formula.</p><h1 id=algorithm>Algorithm</h1><p>For the Pico-8 engine, the algorithm is going to be different than the one that
is generally given in a math-based answer. This is due to two factors:</p><ul><li>The Y-axis is inverted. Usually negative numbers are lower than positive.<ul><li>When dealing with screens, one must remember that (0,0) is the top-left most
point.</li></ul></li><li>The cos and sin functions operate differently than in other languages.<ul><li>From the <a href=https://pico-8.fandom.com/wiki/Cos>documentation</a>: <i>PICO-8 uses an input range of 0.0 to 1.0 to
represent the angle, a percentage of the unit circle. Some refer to these
units as &ldquo;turns&rdquo;. For instance, 180° or π (3.14159) radians corresponds to
0.5 turns in PICO-8&rsquo;s representation of angles. In fact, for fans of τ
(tau), it&rsquo;s just a matter of dropping τ from your expression.</i></li><li>Also it looks like the rotation is reversed. Positive is clockwise, not
counter-clockwise.</li></ul></li></ul><p>new x = x + R * cos(A / 360)<br>new y = y + R * sin(A / 360)</p><p>Where:</p><ul><li>R = The radius of the circle that is made between the origin and the point</li><li>A = The degrees off of the base facing angle (0-360 inclusive)</li></ul><h1 id=example-case-asteroids-spaceship>Example case: Asteroids Spaceship</h1><p>In my specific case, I was doing a 2D Asteroids remake where I had a player with
a given X/Y position. Based on this position, I would draw three lines that go
between points which outlined the ship to create a triangle. These points were
given as measurements off of the player&rsquo;s position as though they were facing
north.</p><p>In order for me to handle rotation, an additional variable was kept for the
angle that the player was currently facing given in terms of 360 degrees. If it
was the case that a player was going to go above or below the 0-359 degree
rotation thresholds, then it would wrap around to the other side to complete the
circle.</p><h2 id=setup-code>Setup code</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#6272a4>-- Create a table to hold the player&#39;s variables</span>
</span></span><span style=display:flex><span>player <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>-- For the game engine I was using, the screen was always 128x128.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>-- Initialize the player&#39;s location, starting in the middle.</span>
</span></span><span style=display:flex><span>player.x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>64</span>
</span></span><span style=display:flex><span>player.y <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>-- New variable for keeping track of where the player is facing</span>
</span></span><span style=display:flex><span>player.direction <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>275</span></span></span></code></pre></div><h1 id=example-case-code>Example Case Code</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#ff79c6>function</span> <span style=color:#50fa7b>draw_spaceship</span>(x, y, ship_angle)
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- First, we calculate where the nose of the plane is.</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>local</span> nose_angle <span style=color:#ff79c6>=</span> ship_angle <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>180</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- Then we generate the points using the formula</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>local</span> nose_x <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>4</span> <span style=color:#ff79c6>*</span> cos(nose_angle<span style=color:#ff79c6>/</span><span style=color:#bd93f9>360</span>)
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>local</span> nose_y <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>4</span> <span style=color:#ff79c6>*</span> sin(nose_angle<span style=color:#ff79c6>/</span><span style=color:#bd93f9>360</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- Next, we must gather the two other points</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- creating a table to hold the x/y pairs.</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>local</span> line_points <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- The spaceship itself has a point with 60 degrees.</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- We will grab points 30 degrees off the center line.</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- Think of this like folding a paper airplane.</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> angle <span style=color:#ff79c6>in</span> all({<span style=color:#bd93f9>30</span>,<span style=color:#ff79c6>-</span><span style=color:#bd93f9>30</span>}) <span style=color:#ff79c6>do</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>-- We will need these points later to finish the ship.</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>local</span> x <span style=color:#ff79c6>=</span> x <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>4</span> <span style=color:#ff79c6>*</span> cos((ship_angle <span style=color:#ff79c6>+</span> angle)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>360</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>local</span> y <span style=color:#ff79c6>=</span> y <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>4</span> <span style=color:#ff79c6>*</span> sin((ship_angle <span style=color:#ff79c6>+</span> angle)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>360</span>)
</span></span><span style=display:flex><span>    add(line_points, {x,y})
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>-- But we can use the nose and the current point as well.</span>
</span></span><span style=display:flex><span>    line(nose_x,nose_y,x,y,<span style=color:#bd93f9>7</span>)
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>-- Finally, connect the two legs of the spaceship</span>
</span></span><span style=display:flex><span>  line(
</span></span><span style=display:flex><span>    line_points[<span style=color:#bd93f9>1</span>][<span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>    line_points[<span style=color:#bd93f9>1</span>][<span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>    line_points[<span style=color:#bd93f9>2</span>][<span style=color:#bd93f9>1</span>],
</span></span><span style=display:flex><span>    line_points[<span style=color:#bd93f9>2</span>][<span style=color:#bd93f9>2</span>],
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>7</span>
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span><span style=color:#ff79c6>end</span></span></span></code></pre></div><h1 id=conclusion>Conclusion</h1><p>The algorithm that can be applied to a number of points around a fixed position
allows for their rotation which, in some cases (especially vector graphics
games), can be the desired effect.</p><p>Note that the rotation may need to be accounted for in one&rsquo;s code dealing with
collision detection. This may also work in a 3D space if the rotation that is
being applied only happens in a single plane that is at a right-angle. Any
deviation from that would require that the third dimension be accounted for in
the calculation.</p></article></div></section></main><footer id=footer>Copyright © 2022 Vlek</footer></body></html>